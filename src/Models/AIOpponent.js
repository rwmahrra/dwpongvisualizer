/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";

const mqtt = require('mqtt')
const client = mqtt.connect(process.env.REACT_APP_URL)
client.on('connect', function () {
  client.subscribe('player1/score', function (err) {
    if (!err) {
      console.log("player1 score")
    }
  })

  client.subscribe('player2/score', function (err) {
    if (!err) {
      console.log("connection pad1")
    }
  })

  client.subscribe('game/level', function (err) {
    if (!err) {
      console.log("connection game level")
    }
  })

  client.subscribe('motion/presence', function (err) {
    if (!err) {
      console.log("connection presence")
    }
  })

  client.subscribe('puck/position', function (err) {
    if (!err) {
      console.log("connection puck position")
    }
  })
});


/**
 * Helper function to change emotions over period of time
 * blatantly copied from : https://iqcode.com/code/javascript/lerp-javascript
 * @param {*} v0 
 * @param {*} v1 
 * @param {*} amt 
 * @param {*} maxMove 
 * @param {*} minDiff 
 * @returns 
 */
const lerp = (v0, v1, amt, maxMove = 0, minDiff = 0.01) => {
  let diff = v1 - v0
  if(maxMove > 0) {
    diff = Math.min(diff, maxMove)
    diff = Math.max(diff, -maxMove)
  }
  if(Math.abs(diff) < minDiff) {
    return v1
  }
  return v0 + diff * amt
}


const emotes = {
  Happy: 0,
  Frustrated: 1,
  Mad: 2,
  Smug: 3,
  Sad: 4,
  Right: 5,
  Left: 6,
  Confused: 7,
}


export default function AIOpponent(props) {


  const group = useRef();
  const face = useRef();
  const hour = useRef();
  const minute = useRef();
  const { nodes, materials } = useGLTF("/AIOpponent.glb");

  // we can change emotes based on the changes in these values
  let currentBallPosition = {x: 0, y: 0}
  let currentPlayerScore = 0
  let currentOpponentScore = 0
  let currentGameLevel = 0
  let currentPresence = false

  let clockStart = false

  let emotionBaseline = [1,0,0,0,0,0,0] // moderately happy
  let emotionTarget = [0,0,0,0,0,0,0]

  let rotationTarget = 0
  let positionTarget = 0

  let morph = (target, value) => {
    face.current.morphTargetInfluences[face.current.morphTargetDictionary[target]] = value;
  }

  let resetMorphTargets = () => {
    emotionTarget = [0,0,0,0,0,0,0]
    rotationTarget = 0;
  }

  /**
   * Used for smooth movement to a new state
   * @param {*} targetArray 
   * @param {*} value 
   */
  let lerpMorphTargets = (targetArray, value) => {
    for (let i = 0; i < 7; i++){
      let newValue = lerp(face.current.morphTargetInfluences[i], targetArray[i], value)
      face.current.morphTargetInfluences[i] = newValue;
    }
  }
  
  useEffect(() => {
    console.log(face.current.morphTargetDictionary)
    console.log(face.current.morphTargetInfluences)

    client.on('message', function (topic, messsage) {
      const data = JSON.parse(messsage.toString())
      switch(topic) {
        case "puck/position":
          let posx = data.x
          // 192 for the game field size
          let pos = posx / 192 // percentage across the game field
          let look = 0.5 - pos
          if(look > 0) {
            // look to the right
            rotationTarget = -look / 2 
            positionTarget = -look
            
          } else {
            // look is neg 
            rotationTarget = -look / 2
            positionTarget = -look
            
          }
          break;
        case "player1/score":
          let score1 = data.score;
          if (score1 != currentPlayerScore && score1 > 0) {
            currentPlayerScore = score1
              // AI gets frustrated - mad might be too intense for the kids
              // resetMorphTargets()
              emotionTarget[emotes["Happy"]] = 0
              emotionTarget[emotes["Frustrated"]] = 1
              emotionTarget[emotes["Smug"]] = 0
              clockStart = true;
          }
          break;
        case "player2/score":
          let score2 = data.score;
          if (score2 != currentOpponentScore && score2 > 0) {
            currentOpponentScore = score2
              // AI gets Happy
              // resetMorphTargets()
              emotionTarget[emotes["Happy"]] = 0
              emotionTarget[emotes["Frustrated"]] = 0
              emotionTarget[emotes["Smug"]] = 1
              clockStart = true;
          }
          break;
        case "game/level": 
          let level = data.level;
          if (level != currentGameLevel) {
              emotionTarget[emotes["Happy"]] = 1
              emotionTarget[emotes["Frustrated"]] = 0
              emotionTarget[emotes["Smug"]] = 0
          }
      }
    })
    
  })

  useFrame(({clock}) => {
    if(clockStart) {
      clock.start()
      console.log("started clock")
      clockStart = false
      
    }
    if(clock.getElapsedTime() > 2){
      lerpMorphTargets(emotionBaseline, .05)
    } else {
      lerpMorphTargets(emotionTarget, .1)
    }

    group.current.rotation.y = lerp(group.current.rotation.y, rotationTarget, 1)

    group.current.position.x = lerp(group.current.position.x, positionTarget, .1)

    hour.current.rotation.z = lerp(hour.current.rotation.z, -clock.getElapsedTime() / 2, .1)
    minute.current.rotation.z = lerp(minute.current.rotation.z, -clock.getElapsedTime(), .1)
    
    
  })




  return (
    <group ref={group} {...props} dispose={null}>
      <group scale={[1.07, 1.07, 1]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube001.geometry}
          material={nodes.Cube001.material}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube001_1.geometry}
          material={materials.Backing}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Backing001.geometry}
          material={nodes.Backing001.material}
          position={[0, 0, -0.02]}
          rotation={[0, 0, -Math.PI / 4]}
          scale={[0.94, 0.94, 1]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Backing002.geometry}
          material={nodes.Backing002.material}
          position={[0, 0, -0.02]}
          rotation={[0, 0, -2.36]}
          scale={[0.94, 0.94, 1]}
        />
        <mesh
          ref = {hour}
          castShadow
          receiveShadow
          geometry={nodes.Hour_Hand.geometry}
          material={nodes.Hour_Hand.material}
          rotation={[0, 0, 0]}
        />
        <mesh
          ref = {minute}
          castShadow
          receiveShadow
          geometry={nodes.Mintue_Hand.geometry}
          material={nodes.Mintue_Hand.material}
          rotation={[0, 0, 0]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Times.geometry}
          material={nodes.Times.material}
        />
      </group>
      <mesh
        ref = {face}
        name="Face"
        castShadow
        receiveShadow
        geometry={nodes.Face.geometry}
        material={nodes.Face.material}
        morphTargetDictionary={nodes.Face.morphTargetDictionary}
        morphTargetInfluences={nodes.Face.morphTargetInfluences}
      />
    </group>
  );
}

useGLTF.preload("/AIOpponent.glb");
